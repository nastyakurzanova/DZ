// Вычисление факториала рекурсивным и итеративным методами
// Ветви условия в данной функции демонстрируют необязательный вариант
// неявного возврата значений, что может быть удобно при использовании 
// "функционального" стиля. В отличие от C++ и других родственных языков, 
// в Rust if - это выражение, возвращающее значение, а не просто оператор. 
fn fac_recur(n: i32) -> i32 {
    if n <= 1 {
        1
    } else {
        n * fac_recur(n-1)
    }
}

fn fac_iter(n: i32) -> i32 {
    // Переменные объявляются с ключевым словом "let", по умолчанию
    // не изменяемые. Если нужна их изменяемость, добавляется ключевое
    // слово 'mut'.
    let mut i = 1;
    let mut result = 1;
    while i <= n {
        result *= i;
        i += 1;
    }
    return result; // Пример явно возвращаемого значения.
}

fn fac_lambda(n: i32) -> i32 {
    // "|accum, x|" - это определение анонимной функции.
    // Замыкания в Rust, так же называемые лямбда, это функции, которые замыкают своё окружение.
  // fold - потребитель
  // (1..=n) - создает значения, представляющее последовательность, от 1 до n, ленивое 
  // 1 - база с начала, accum - аккумулятор, х - элемент
    (1..=n).fold(1, |accum, x| accum * x)
}
// перебираетпроизведение наборов элементов двух итераторов
fn fac_iter1(n: i32) -> i32 {
  // product() - ф-ция, которая умножает числа от (1..n)
    (1..=n).product()
}
fn main() {
    let num = 4;
    println!("Recursive result: {}", fac_recur(num));
    println!("Iterative result: {}", fac_iter(num));
    println!("Iterative result: {}", fac_iter1(num));
    println!("Lambda result: {}", fac_lambda(num));
}"# DZ" 
